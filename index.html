<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pathfinding Visualizer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #1e1e1e;
      color: #fff;
      text-align: center;
      margin: 0;
      padding: 0;
    }

    h1 {
      margin: 20px;
    }

    .controls {
      margin-bottom: 10px;
    }

    .controls button,
    .controls input {
      margin: 5px;
      padding: 10px;
      border: none;
      border-radius: 5px;
    }

    .controls input {
      width: 60px;
    }

    .controls button {
      cursor: pointer;
      background-color: #444;
      color: #fff;
      transition: background-color 0.3s;
    }

    .controls button:hover {
      background-color: #666;
    }

    #grid {
      display: grid;
      justify-content: center;
      gap: 2px;
    }

    .cell {
      width: 30px;
      height: 30px;
      background-color: #333;
      border: 1px solid #222;
      transition: background-color 0.2s;
    }

    .cell.start {
      background-color: green;
    }

    .cell.end {
      background-color: red;
    }

    .cell.wall {
      background-color: #000;
    }

    .cell.visited {
      background-color: #3498db;
    }

    .cell.path {
      background-color: yellow;
    }
  </style>
</head>
<body>
  <h1>Pathfinding Visualizer (BFS & DFS)</h1>

  <div class="controls">
    Rows: <input type="number" id="rowsInput" value="8" min="5" max="50">
    Columns: <input type="number" id="colsInput" value="8" min="5" max="50">
    Start (row,col): <input type="text" id="startInput" value="0,0">
    End (row,col): <input type="text" id="endInput" value="7,7">
    <button onclick="createGrid()">Create Grid</button>
    <button onclick="startPathfinding('bfs')">Visualize BFS</button>
    <button onclick="startPathfinding('dfs')">Visualize DFS</button>
    <button onclick="resetGrid()">Reset Grid</button>
  </div>

  <div id="grid"></div>

  <script>
    let rows = 8;
    let cols = 8;
    let grid = [];
    let startCell, endCell;

    const gridContainer = document.getElementById("grid");

    function createGrid() {
      rows = parseInt(document.getElementById("rowsInput").value);
      cols = parseInt(document.getElementById("colsInput").value);
      const startCoords = document.getElementById("startInput").value.split(',').map(Number);
      const endCoords = document.getElementById("endInput").value.split(',').map(Number);

      if (startCoords.length !== 2 || endCoords.length !== 2) return alert("Invalid start/end coordinates");

      gridContainer.innerHTML = "";
      gridContainer.style.gridTemplateColumns = `repeat(${cols}, 30px)`;

      grid = [];
      for (let r = 0; r < rows; r++) {
        grid[r] = [];
        for (let c = 0; c < cols; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.addEventListener("click", () => toggleWall(cell));
          gridContainer.appendChild(cell);
          grid[r][c] = cell;
        }
      }
      startCell = grid[startCoords[0]][startCoords[1]];
      endCell = grid[endCoords[0]][endCoords[1]];
      startCell.classList.add("start");
      endCell.classList.add("end");
    }

    function toggleWall(cell) {
      if (cell === startCell || cell === endCell) return;
      cell.classList.toggle("wall");
    }

    function getNeighbors(cell) {
      const row = +cell.dataset.row;
      const col = +cell.dataset.col;
      const neighbors = [];
      const directions = [
        [0, 1], [1, 0], [-1, 0], [0, -1]
      ];
      for (let [dr, dc] of directions) {
        let nr = row + dr;
        let nc = col + dc;
        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
          const neighbor = grid[nr][nc];
          if (!neighbor.classList.contains("wall")) {
            neighbors.push(neighbor);
          }
        }
      }
      return neighbors;
    }

    async function bfs(start, end) {
      const queue = [start];
      const visited = new Set();
      const parent = new Map();
      visited.add(start);

      while (queue.length > 0) {
        const current = queue.shift();
        if (current === end) break;

        for (let neighbor of getNeighbors(current)) {
          if (!visited.has(neighbor)) {
            queue.push(neighbor);
            visited.add(neighbor);
            parent.set(neighbor, current);
            if (neighbor !== end) neighbor.classList.add("visited");
            await sleep(100);
          }
        }
      }
      reconstructPath(parent, end);
    }

    async function dfs(start, end) {
      const stack = [start];
      const visited = new Set();
      const parent = new Map();
      visited.add(start);

      while (stack.length > 0) {
        const current = stack.pop();
        if (current === end) break;

        for (let neighbor of getNeighbors(current)) {
          if (!visited.has(neighbor)) {
            stack.push(neighbor);
            visited.add(neighbor);
            parent.set(neighbor, current);
            if (neighbor !== end) neighbor.classList.add("visited");
            await sleep(100);
          }
        }
      }
      reconstructPath(parent, end);
    }

    async function reconstructPath(parent, end) {
      let current = end;
      const path = [];
      while (parent.has(current)) {
        path.push(current);
        current = parent.get(current);
      }
      path.reverse();
      for (let cell of path) {
        if (cell !== end) cell.classList.add("path");
        await sleep(150);
      }
    }

    function sleep(ms) {
      return new Promise(res => setTimeout(res, ms));
    }

    function resetGrid() {
      for (let row of grid) {
        for (let cell of row) {
          cell.className = "cell";
        }
      }
      const startCoords = document.getElementById("startInput").value.split(',').map(Number);
      const endCoords = document.getElementById("endInput").value.split(',').map(Number);
      startCell = grid[startCoords[0]][startCoords[1]];
      endCell = grid[endCoords[0]][endCoords[1]];
      startCell.classList.add("start");
      endCell.classList.add("end");
    }

    async function startPathfinding(type) {
      resetGrid();
      if (type === 'bfs') await bfs(startCell, endCell);
      else if (type === 'dfs') await dfs(startCell, endCell);
    }

    createGrid();
  </script>
</body>
</html>